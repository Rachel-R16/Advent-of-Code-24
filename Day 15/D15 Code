from collections import deque

# Read input data from file
with open('D15 Input') as file:
    input_data = file.read().strip()

# Split input into grid layout and movement instructions
room_data, moves = input_data.split('\n\n')
grid = room_data.split('\n')


def enlarge_grid(rows, cols, grid):
    #Function to double the grid for part 2 by modifying the content of the cells.
    enlarged_grid = []
    for r in range(rows):
        new_row = []
        for c in range(cols):
            if grid[r][c] == '#':
                new_row.append('#')
                new_row.append('#')
            elif grid[r][c] == 'O':
                new_row.append('[')
                new_row.append(']')
            elif grid[r][c] == '.':
                new_row.append('.')
                new_row.append('.')
            elif grid[r][c] == '@':
                new_row.append('@')
                new_row.append('.')
        enlarged_grid.append(new_row)

    # Double the number of columns in the grid
    cols *= 2
    return rows, cols, enlarged_grid


def process_room_movement(grid, enlarge=False):
    # Function to simulate movement in the grid based on instructions,
    # with the option to enlarge the grid (Part 2).
    rows = len(grid)
    cols = len(grid[0])

    # Create a 2D list of the grid
    grid = [[grid[r][c] for c in range(cols)] for r in range(rows)]

    # Enlarge the grid if required
    if enlarge:
        rows, cols, grid = enlarge_grid(rows, cols, grid)

    # Find the starting position '@'
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '@':
                start_row, start_col = r, c
                grid[r][c] = '.'

    # Initialize current position as the starting position
    row, col = start_row, start_col

    # Process each movement instruction
    for move in moves:
        if move == '\n':
            continue  # Skip newline characters

        # Determine the direction based on the movement symbol
        d_row, d_col = {'^': (-1, 0), '>': (0, 1), 'v': (1, 0), '<': (0, -1)}[move]

        # Calculate the new position
        new_row, new_col = row + d_row, col + d_col

        # Skip the move if the new position is a wall
        if grid[new_row][new_col] == '#':
            continue

        # Move to the new position if it's empty
        elif grid[new_row][new_col] == '.':
            row, col = new_row, new_col

        # Handle movement into a container (denoted by '[' or ']')
        elif grid[new_row][new_col] in ['[', ']', 'O']:
            queue = deque([(row, col)])  # Initialize BFS queue
            visited = set()  # Track visited positions
            valid_move = True  # Flag to check if move is valid

            # Perform BFS to find all reachable positions within the container
            while queue:
                cur_row, cur_col = queue.popleft()

                if (cur_row, cur_col) in visited:
                    continue

                visited.add((cur_row, cur_col))
                next_row, next_col = cur_row + d_row, cur_col + d_col

                if grid[next_row][next_col] == '#':
                    is_valid = False
                    break
                if grid[next_row][next_col] == 'O':
                    queue.append((next_row, next_col))
                elif grid[next_row][next_col] == '[':
                    queue.append((next_row, next_col))
                    assert grid[next_row][next_col + 1] == ']'
                    queue.append((next_row, next_col + 1))
                elif grid[next_row][next_col] == ']':
                    queue.append((next_row, next_col))
                    assert grid[next_row][next_col - 1] == '['
                    queue.append((next_row, next_col - 1))

            if not is_valid:
                continue

            # Move items inside the container
            while visited:
                for cur_row, cur_col in sorted(visited):
                    next_row, next_col = cur_row + d_row, cur_col + d_col
                    if (next_row, next_col) not in visited:
                        assert grid[next_row][next_col] == '.'
                        grid[next_row][next_col] = grid[cur_row][cur_col]
                        grid[cur_row][cur_col] = '.'
                        visited.remove((cur_row, cur_col))

            # Update current position
            row, col = row + d_row, col + d_col

    return rows, cols, grid


def calculate_gps(rows, cols, grid):
    #Function to calculate the GPS (Weighted Sum of positions) for all boxes in the grid.
    result = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] in ['[', 'O']:  # Only consider boxes
                result += 100 * r + c  # Weight position by row and column
    return result


# Solve for Part 1 with the original grid
rows, cols, grid = process_room_movement(grid, enlarge=False)
print("Part 1 - Sum of GPS of all boxes in room:", calculate_gps(rows, cols, grid))

# Solve for Part 2 with the enlarged grid
rows, cols, grid = process_room_movement(grid, enlarge=True)
print("Part 2 - Sum of GPS of all boxes in enlarged room:", calculate_gps(rows, cols, grid))
